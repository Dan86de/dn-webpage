---
export interface Props {
  variant?:
    | "default"
    | "blue"
    | "yellow"
    | "pink"
    | "react"
    | "ts"
    | "js"
    | "nodejs"
    | "bun"
    | "tailwindcss"
    | "motion"
    | "tanstack";
  gap?: number;
  speed?: number;
  colors?: string;
  noFocus?: boolean;
  className?: string;
}

const VARIANTS = {
  default: {
    activeColor: null,
    gap: 5,
    speed: 35,
    colors: "#f8fafc,#f1f5f9,#cbd5e1",
    noFocus: false,
  },
  tanstack: {
    activeColor: "#6BDAFF",
    gap: 5,
    speed: 35,
    colors: "#6BDAFF,#FFA770,#FF7373",
    noFocus: false,
  },
  motion: {
    activeColor: "#FFF312",
    gap: 5,
    speed: 35,
    colors: "#FFF312,#0f0f0f,#cbd5e1",
    noFocus: false,
  },
  tailwindcss: {
    activeColor: "#38bdf8",
    gap: 5,
    speed: 25,
    colors: "#38bdf8,#22d3ee,#0ea5e9",
    noFocus: false,
  },
  bun: {
    activeColor: "#ff6164",
    gap: 5,
    speed: 25,
    colors: "#ff6164,#ccbea7,#f6dece",
    noFocus: false,
  },
  react: {
    activeColor: "#58C4DC",
    gap: 5,
    speed: 35,
    colors: "#58C4DC,#2D98B4,#087EA4",
    noFocus: false,
  },
  nodejs: {
    activeColor: "#66B848",
    gap: 5,
    speed: 25,
    colors: "#6CC04A,#419637,#418B3D",
    noFocus: false,
  },
  ts: {
    activeColor: "#3178C6",
    gap: 5,
    speed: 25,
    colors: "#3178C6,#358EF1,#235A97",
    noFocus: false,
  },
  js: {
    activeColor: "#f7df1e",
    gap: 5,
    speed: 25,
    colors: "#f7df1e,#f7ca1e,#f7b81e",
    noFocus: false,
  },
  blue: {
    activeColor: "#e0f2fe",
    gap: 10,
    speed: 25,
    colors: "#e0f2fe,#7dd3fc,#0ea5e9",
    noFocus: false,
  },
  yellow: {
    activeColor: "#fef08a",
    gap: 3,
    speed: 20,
    colors: "#fef08a,#fde047,#eab308",
    noFocus: false,
  },
  pink: {
    activeColor: "#fecdd3",
    gap: 6,
    speed: 80,
    colors: "#fecdd3,#fda4af,#e11d48",
    noFocus: true,
  },
};

const {
  variant = "default",
  gap,
  speed,
  colors,
  noFocus,
  className = "",
} = Astro.props;

const variantCfg = VARIANTS[variant] || VARIANTS.default;
const finalGap = gap ?? variantCfg.gap;
const finalSpeed = speed ?? variantCfg.speed;
const finalColors = colors ?? variantCfg.colors;
const finalNoFocus = noFocus ?? variantCfg.noFocus;
---

<div
  class={`pixel-card size-10 relative overflow-hidden grid place-items-center aspect-4/5 isolate transition-colors duration-200 ease-[cubic-bezier(0.5,1,0.89,1)] select-none ${className}`}
  data-gap={finalGap}
  data-speed={finalSpeed}
  data-colors={finalColors}
  data-no-focus={finalNoFocus}
  tabindex={finalNoFocus ? -1 : 0}
>
  <canvas class="absolute inset-0 block"></canvas>
  <slot />
</div>

<script>
  class Pixel {
    width: number;
    height: number;
    ctx: CanvasRenderingContext2D;
    x: number;
    y: number;
    color: string;
    speed: number;
    size: number;
    sizeStep: number;
    minSize: number;
    maxSizeInteger: number;
    maxSize: number;
    delay: number;
    counter: number;
    counterStep: number;
    isIdle: boolean;
    isReverse: boolean;
    isShimmer: boolean;

    constructor(
      canvas: HTMLCanvasElement,
      context: CanvasRenderingContext2D,
      x: number,
      y: number,
      color: string,
      speed: number,
      delay: number,
    ) {
      this.width = canvas.width;
      this.height = canvas.height;
      this.ctx = context;
      this.x = x;
      this.y = y;
      this.color = color;
      this.speed = this.getRandomValue(0.1, 0.9) * speed;
      this.size = 0;
      this.sizeStep = Math.random() * 0.4;
      this.minSize = 0.5;
      this.maxSizeInteger = 2;
      this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);
      this.delay = delay;
      this.counter = 0;
      this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;
      this.isIdle = false;
      this.isReverse = false;
      this.isShimmer = false;
    }

    getRandomValue(min: number, max: number) {
      return Math.random() * (max - min) + min;
    }

    draw() {
      const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;
      this.ctx.fillStyle = this.color;
      this.ctx.fillRect(
        this.x + centerOffset,
        this.y + centerOffset,
        this.size,
        this.size,
      );
    }

    appear() {
      this.isIdle = false;
      if (this.counter <= this.delay) {
        this.counter += this.counterStep;
        return;
      }
      if (this.size >= this.maxSize) {
        this.isShimmer = true;
      }
      if (this.isShimmer) {
        this.shimmer();
      } else {
        this.size += this.sizeStep;
      }
      this.draw();
    }

    disappear() {
      this.isShimmer = false;
      this.counter = 0;
      if (this.size <= 0) {
        this.isIdle = true;
        return;
      } else {
        this.size -= 0.1;
      }
      this.draw();
    }

    shimmer() {
      if (this.size >= this.maxSize) {
        this.isReverse = true;
      } else if (this.size <= this.minSize) {
        this.isReverse = false;
      }
      if (this.isReverse) {
        this.size -= this.speed;
      } else {
        this.size += this.speed;
      }
    }
  }

  function getEffectiveSpeed(value: number, reducedMotion: boolean) {
    const min = 0;
    const max = 100;
    const throttle = 0.001;

    if (value <= min || reducedMotion) {
      return min;
    } else if (value >= max) {
      return max * throttle;
    } else {
      return value * throttle;
    }
  }

  class PixelCardController {
    container: HTMLElement;
    canvas: HTMLCanvasElement;
    pixels: Pixel[] = [];
    animationFrame: number | null = null;
    timePrevious: number = performance.now();
    reducedMotion: boolean;
    finalGap: number;
    finalSpeed: number;
    finalColors: string;
    finalNoFocus: boolean;
    resizeObserver: ResizeObserver | null = null;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector("canvas")!;
      this.reducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)",
      ).matches;

      this.finalGap = parseInt(container.dataset.gap || "5");
      this.finalSpeed = parseInt(container.dataset.speed || "35");
      this.finalColors = container.dataset.colors || "#f8fafc,#f1f5f9,#cbd5e1";
      this.finalNoFocus = container.dataset.noFocus === "true";

      this.init();
    }

    init() {
      this.initPixels();
      this.setupEventListeners();
      this.setupResizeObserver();
    }

    initPixels() {
      const rect = this.container.getBoundingClientRect();
      const width = Math.floor(rect.width);
      const height = Math.floor(rect.height);
      const ctx = this.canvas.getContext("2d");

      if (!ctx) return;

      this.canvas.width = width;
      this.canvas.height = height;
      this.canvas.style.width = `${width}px`;
      this.canvas.style.height = `${height}px`;

      const colorsArray = this.finalColors.split(",");
      const pxs: Pixel[] = [];

      for (let x = 0; x < width; x += this.finalGap) {
        for (let y = 0; y < height; y += this.finalGap) {
          const color =
            colorsArray[Math.floor(Math.random() * colorsArray.length)];
          const dx = x - width / 2;
          const dy = y - height / 2;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const delay = this.reducedMotion ? 0 : distance;

          pxs.push(
            new Pixel(
              this.canvas,
              ctx,
              x,
              y,
              color,
              getEffectiveSpeed(this.finalSpeed, this.reducedMotion),
              delay,
            ),
          );
        }
      }

      this.pixels = pxs;
    }

    doAnimate(fnName: "appear" | "disappear") {
      this.animationFrame = requestAnimationFrame(() => this.doAnimate(fnName));

      const timeNow = performance.now();
      const timePassed = timeNow - this.timePrevious;
      const timeInterval = 1000 / 60;

      if (timePassed < timeInterval) return;
      this.timePrevious = timeNow - (timePassed % timeInterval);

      const ctx = this.canvas.getContext("2d");
      if (!ctx) return;

      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      let allIdle = true;
      for (const pixel of this.pixels) {
        pixel[fnName]();
        if (!pixel.isIdle) {
          allIdle = false;
        }
      }

      if (allIdle && this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
      }
    }

    handleAnimation(name: "appear" | "disappear") {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
      }
      this.animationFrame = requestAnimationFrame(() => this.doAnimate(name));
    }

    setupEventListeners() {
      this.container.addEventListener("mouseenter", () =>
        this.handleAnimation("appear"),
      );
      this.container.addEventListener("mouseleave", () =>
        this.handleAnimation("disappear"),
      );

      if (!this.finalNoFocus) {
        this.container.addEventListener("focus", (e: FocusEvent) => {
          if (this.container.contains(e.relatedTarget as Node)) return;
          this.handleAnimation("appear");
        });
        this.container.addEventListener("blur", (e: FocusEvent) => {
          if (this.container.contains(e.relatedTarget as Node)) return;
          this.handleAnimation("disappear");
        });
      }
    }

    setupResizeObserver() {
      this.resizeObserver = new ResizeObserver(() => {
        this.initPixels();
      });
      this.resizeObserver.observe(this.container);
    }

    destroy() {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
      }
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }
    }
  }

  // Initialize all pixel cards on the page
  function initializePixelCards() {
    const cards = document.querySelectorAll<HTMLElement>(".pixel-card");
    cards.forEach((card) => {
      // Prevent double initialization
      if (!(card as any).__pixelCardController) {
        (card as any).__pixelCardController = new PixelCardController(card);
      }
    });
  }

  // Support both regular page loads and Astro view transitions
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializePixelCards);
  } else {
    // DOM is already loaded
    initializePixelCards();
  }

  // Also support Astro view transitions if enabled
  document.addEventListener("astro:page-load", initializePixelCards);
</script>
